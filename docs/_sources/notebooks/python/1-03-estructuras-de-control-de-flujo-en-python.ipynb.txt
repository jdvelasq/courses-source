{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Estructuras de Control de Flujo en Python\n",
    "===\n",
    "\n",
    "* *90 min*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Estructura if"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La identación usando espacios en blanco es el mecanismo definido en Python para delimitar el cuerpo asociado a las estructuras de control y a las funciones de usuario. \n",
    "\n",
    "En el siguiente ejemplo, la estructura `else if` es reemplazada comunmente por la palabra reservada `elif`. El uso del caracter `:` es obligatorio."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Please enter an integer: 1\n",
      "Single\n"
     ]
    }
   ],
   "source": [
    "# este código es mucho más dificil de leer.\n",
    "x = 10\n",
    "if x < 0:\n",
    "    x = 0\n",
    "    print('Negative changed to zero')\n",
    "else:\n",
    "    if x == 0:\n",
    "        print('Zero')\n",
    "    else:\n",
    "        if x == 1:\n",
    "            print('Single')\n",
    "        else:\n",
    "            print('More')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Please enter an integer: 2\n",
      "More\n"
     ]
    }
   ],
   "source": [
    "# código mucho más legible\n",
    "x = 10\n",
    "if x < 0:\n",
    "    x = 0\n",
    "    print('Negative changed to zero')\n",
    "elif x == 0:\n",
    "    print('Zero')\n",
    "elif x == 1:\n",
    "    print('Single')\n",
    "else:\n",
    "    print('More')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "x = 1 if False else 0\n",
    "x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Estructura for"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El comando `for` permite iterar sobre los elementos de una lista."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "cat 3\n",
      "window 6\n",
      "door 4\n",
      "abcdefg 7\n"
     ]
    }
   ],
   "source": [
    "words = ['cat', 'window', 'door', 'abcdefg']\n",
    "for w in words:\n",
    "    print(w, len(w))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "2\n",
      "3\n"
     ]
    }
   ],
   "source": [
    "for n in list(range(4)):\n",
    "    print(n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "cat\n",
      "window\n",
      "door\n",
      "abcdefg\n"
     ]
    }
   ],
   "source": [
    "for n in range(len(words)):\n",
    "    print(words[n])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['abcdefg', 'cat', 'window', 'door', 'abcdefg']"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "for w in words[:]:  # words[:] genera una nueva lista diferente a la contenida en words.\n",
    "    if len(w) > 6:\n",
    "        words.insert(0, w)\n",
    "\n",
    "words"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La función `range(n)` devuelve un objeto cuyos elementos son los enteros consecutivos desde `0` hasta `n-1`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "2\n",
      "3\n",
      "4\n"
     ]
    }
   ],
   "source": [
    "for i in range(5):\n",
    "    print(i)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "range(0, 5)"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "range(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[0, 1, 2, 3, 4]"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(range(5))  # un rango puede convertirse en una lista"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "5, 6, 7, 8, 9, "
     ]
    }
   ],
   "source": [
    "for i in range(5, 10):\n",
    "    print(i, end = ', ') # el argumento end indica que al final del print se imprime ', ' y no retorno de carro"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0, 3, 6, 9, "
     ]
    }
   ],
   "source": [
    "for i in range(0, 10, 3):\n",
    "    print(i, end = ', ')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "-10, -40, -70, "
     ]
    }
   ],
   "source": [
    "for i in range(-10, -100, -30):\n",
    "    print(i, end = ', ')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En el comando `for` existen dos formas para obtener un elemento de una lista y su posición. La primera es generar los indices usando `range` y con ellos obtener los elementos:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 a\n",
      "1 b\n",
      "2 c\n",
      "3 d\n",
      "4 e\n"
     ]
    }
   ],
   "source": [
    "a = ['a', 'b', 'c', 'd', 'e']\n",
    "for i in range(len(a)):\n",
    "    print(i, a[i])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La segunda forma es enumerar los elementos de la lista usando la función `enumerate`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "a = ['a', 'b', 'c', 'd', 'e']\n",
    "for x in enumerate(a):\n",
    "    print(x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 a\n",
      "1 b\n",
      "2 c\n",
      "3 d\n",
      "4 e\n"
     ]
    }
   ],
   "source": [
    "for (i, x) in enumerate(a):\n",
    "    print(i, x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comandos break y continue"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El comando `continue` causa que se ejecute una nueva iteración del ciclo `for` sin pasar por el resto del código que hace parte del cuerpo del ciclo `for`. El comando `break` causa la salida del cuerpo del ciclo `for`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n",
      "5\n",
      "6\n",
      "7\n"
     ]
    }
   ],
   "source": [
    "for n in range(1, 10):\n",
    "    if n < 4:\n",
    "        continue \n",
    "    print(n)   # solo pasa por aca cuando n >= 4.\n",
    "    if n > 6:\n",
    "        break  # interrupe el ciclo cuando n > 6."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Estructura while"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El comando `while` permite iterar mientras se cumpla una condición. Al igual que en un ciclo `for`, el código perteneciente al cuerpo del `while` se identifica por identación. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "2\n",
      "3\n",
      "4\n",
      "fin\n"
     ]
    }
   ],
   "source": [
    "n = 0\n",
    "while n < 5:  # se ejecuta mientras se cumpla que n < 5\n",
    "    print(n)\n",
    "    n = n + 1\n",
    "    \n",
    "print('fin')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comando else en estructuras for y while"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Los ciclos creados usando los comandos `for` y `while` pueden contener un comando `else`. En el caso de los ciclos `for`, el cuerpo del `else` se ejecuta cuando se termina el ciclo; para los ciclos `while`, el cuerpo del `else` se ejecuta cuando el condicional se hace falso."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "2\n",
      "3\n",
      "4\n",
      "cuerpo else\n",
      "fin\n"
     ]
    }
   ],
   "source": [
    "n = 0\n",
    "while n < 5:  # se ejecuta mientras se cumpla que n < 5\n",
    "    print(n)\n",
    "    n = n + 1\n",
    "else:\n",
    "    print('cuerpo else')\n",
    "    \n",
    "print('fin')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n",
      "1\n",
      "2\n",
      "3\n",
      "4\n",
      "cuerpo else\n",
      "fin\n"
     ]
    }
   ],
   "source": [
    "for n in range(5):  # se ejecuta mientras se cumpla que n < 5\n",
    "    print(n)\n",
    "    n = n + 1\n",
    "else:\n",
    "    print('cuerpo else')\n",
    "    \n",
    "print('fin')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Funciones de usuario"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Las funciones son definidas mediante la palabra reservada `def`. En el siguiente ejemplo se presenta una función que calcula la serie de Fibonnaci. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 \n"
     ]
    }
   ],
   "source": [
    "def fib(n):    \n",
    "    \"\"\"Imprime los términos de la serie de Fibbonaci que son menores que n.\"\"\"\n",
    "    a, b = 0, 1  # esto equivale a hacer a = 0 y b = 1\n",
    "    while a < n:\n",
    "        print(a, end=' ')\n",
    "        a, b = b, a+b  # equivale a: a = b y b = a + b\n",
    "    print()\n",
    "\n",
    "# Llama la función\n",
    "fib(2000)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<function __main__.fib>"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "fib  # la función es un objeto."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function fib in module __main__:\n",
      "\n",
      "fib(n)\n",
      "    Imprime los términos de la serie de Fibbonaci que son menores que n.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(fib)  # invoca la ayuda de fib"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "f = fib # se almacena el objeto en la variable f"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 1 1 2 3 5 8 13 21 34 55 89 \n"
     ]
    }
   ],
   "source": [
    "f(100)  # terminos de la serie de Fibbonaci menores que 100"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# en vez de imprimir, devuelve los términos de la serie en una lista.\n",
    "def fib2(n):\n",
    "    \"\"\"Retorna los términos de la serie de Fibbonaci que son menores que n en una lista.\"\"\"\n",
    "    result = []  # se crea una lista vacia\n",
    "    a, b = 0, 1\n",
    "    while a < n:\n",
    "        result.append(a)    # se agrega a al final de la lista (opera como un stack)\n",
    "        a, b = b, a+b\n",
    "    return result\n",
    "\n",
    "f100 = fib2(100)    # llama la función\n",
    "f100                # imprime el resultado"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1]\n",
      "[1, 2]\n",
      "[1, 2, 3]\n"
     ]
    }
   ],
   "source": [
    "def f(a, L=[]):\n",
    "    L.append(a)\n",
    "    return L\n",
    "\n",
    "print(f(1))\n",
    "print(f(2))\n",
    "print(f(3))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para solucionar este comportamiento, se hace `L=None` y en el cuerpo se hace `L=[]`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1]\n",
      "[2]\n",
      "[3]\n"
     ]
    }
   ],
   "source": [
    "def f(a, L=None):\n",
    "    if L is None:\n",
    "        L = []\n",
    "    L.append(a)\n",
    "    return L\n",
    "\n",
    "print(f(1))\n",
    "print(f(2))\n",
    "print(f(3))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Las funciones pueden ser invocadas con una cantidad variable de argumentos. En el siguiente ejemplo, los argumentos son guardados como una tupla en la variable `args`. Con el  `*` se indica cual es el argumento que guarda la tupla.   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 2, 3)\n"
     ]
    }
   ],
   "source": [
    "def f(*args): # simplemente imprime los argumentos con que se invoca\n",
    "    print(args)\n",
    "    \n",
    "f(1, 2, 3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En el siguiente ejemplo, se está dando un valor por defecto al argumento `c`, tal que cuando la función es invocada, la variable `c` toma el valor especificado. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "(2, 3, 4, 5)\n",
      "hola\n"
     ]
    }
   ],
   "source": [
    "def f(a, *b, c = 'hola'): \n",
    "    print(a)\n",
    "    print(b)\n",
    "    print(c)\n",
    "    \n",
    "f(1, 2, 3, 4, 5) # el 5 no se asigna a la variable c"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note que a diferencia del caso anterior, en el cual se hacia la llamada `f(1, 2, 3, 4, 5) `, en el siguiente ejemplo se hace explicita la asignación a la variable `c`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "(2, 3, 4)\n",
      "5\n"
     ]
    }
   ],
   "source": [
    "f(1, 2, 3, 4, c=5) # se debe indicar explicitamente que `c = 5`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Python permite la definición de funciones anónimas (que no tienen nombre) usando la palabra reservada `lambda`. En el siguiente ejemplo, se define la función `incr` la cual incrementa en la unidad su argumento."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 31,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def incr(x):\n",
    "    return(x + 1)\n",
    "\n",
    "incr(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Esto es equivalente a asignar una función anónima a una variable:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "incr0 = lambda x:x + 1\n",
    "\n",
    "incr0(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En el código anterior, el código `lambda x:` indica que hay una función anónima con un solo argumento llamado `x`. El código `x + 1` es lo que retorna la función. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "No es necesario realizar la asignación de la función anónima a una variable; la función anónima puede ser usada directamente, tal como se ilustra en el siguiente ejemplo. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(lambda x:x + 1)(2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Las funciones pueden retornar funciones, tal como es el caso presentado a continuación donde `return` devuelve una función anónima. Note que el valor de `n` persiste, tal que la función `f` suma `42` a su argumento y `g` suma `1` a su argumento.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "42"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def make_incrementor(n):\n",
    "    return lambda x: x + n\n",
    "\n",
    "f = make_incrementor(42)\n",
    "f(0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "43"
      ]
     },
     "execution_count": 35,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "f(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "g = make_incrementor(1)\n",
    "g(1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cuando una estructura de control (`if`, `for`, `while`, ...) o una función no tiene código asignado a su cuerpo se usa el comando `pass`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "def my_function():\n",
    "    \"\"\"Do nothing, but document it.\n",
    "\n",
    "    No, really, it doesn't do anything.\n",
    "    \"\"\"\n",
    "    pass"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Por último, el string que sigue al nombre de la función se usa para su documentación. Este puede ser accesado directamente por el comando `help` o mediante `print`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Do nothing, but document it.\n",
      "\n",
      "    No, really, it doesn't do anything.\n",
      "    \n"
     ]
    }
   ],
   "source": [
    "print(my_function.__doc__)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on function my_function in module __main__:\n",
      "\n",
      "my_function()\n",
      "    Do nothing, but document it.\n",
      "    \n",
      "    No, really, it doesn't do anything.\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(my_function)"
   ]
  }
 ],
 "metadata": {
  "kernel_info": {
   "name": "python3"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  },
  "nteract": {
   "version": "0.12.3"
  },
  "toc-autonumbering": false
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
