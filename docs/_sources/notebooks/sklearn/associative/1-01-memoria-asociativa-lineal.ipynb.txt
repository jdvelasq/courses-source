{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Memoria asociativa lineal\n",
    "===\n",
    "\n",
    "* *30 min* | Última modificación: Junio 22, 2019"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Definición del problema real"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Un sistema de transmisión es usado para enviar mensajes entre dos puntos diferentes mediante un alfabeto conformado por los dígitos 0, 1 y 2, los cuales son representados como bits de acuerdo con la figura que aparece abajo. El problema radica en que en el punto de recepción, el patrón recibido puede llegar incompleto o contaminado con ruido por lo que se desea construir un sistema que permita recuperar el patrón original a partir de patrón recibido que está incompleto o contaminado con ruido.  \n",
    "\n",
    "![assets/ModelosAsociativos-01.png](assets/ModelosAsociativos-01.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Definición del problema en términos de los datos"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cada patrón del alfabeto es representado como una cadena de 30 bits (0s y 1s), la cual es transmitida al receptor. Por ejemplo, el patrón del 0 podría ser (por filas):\n",
    "\n",
    "    01110 10001 ... 01110\n",
    "\n",
    "El patrón recibido, cuando está contaminado o incompleto, corresponde a una cadena de 30 bits que no coincide con ninguna de las cadenas que representan el alfabeto original. El problema consiste en tomar una cadena contaminada con ruido y transformarla en la cadena del alfabeto más parecida.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Metodología "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Memoria asociativa"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Definición"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Este problema puede ser solucionado mediante una memoria lineal asociativa, la cual relaciona un patrón de actividad neuronal de entrada  con un patrón de actividad neuronal de salida. Existen dos fases:\n",
    "\n",
    "* **Aprendizaje**: Un patrón clave es presentado como un estímulo. La memoria lo transforma a un patrón almacenado o memorizado.\n",
    "\n",
    "\n",
    "![assets/ModelosAsociativos-02.png](assets/ModelosAsociativos-02.png)\n",
    "\n",
    "* **Uso**: Se presenta una versión del patrón de entrada incompleta o con ruido y la memoria devuelve el patrón almacenado más parecido.\n",
    "\n",
    "![assets/ModelosAsociativos-03.png](assets/ModelosAsociativos-03.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Las características de la memoria asociativa son las siguientes:\n",
    "\n",
    "\n",
    "* La memoria es distribuida.\n",
    "\n",
    "\n",
    "* Los patrones de estímulo y las respuestas son vectores de datos.\n",
    "\n",
    "\n",
    "* La información se almacena en las neuronas a través de un patrón de actividad neural a través de un gran número de neuronas.\n",
    "\n",
    "\n",
    "* La información contenida en el estímulo determina su localización de almacenamiento en la memoria y la dirección para su recuperación.\n",
    "\n",
    "\n",
    "* La memoria tiene un alto grado de resistencia al ruido.\n",
    "\n",
    "\n",
    "* Las interacciones entre patrones son almacenadas en la memoria.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Tipos"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Conceptualmente se reconocen dos **tipos de asociación**:\n",
    "\n",
    "* Autoasociación: El estímulo es asociado consigo mismo en la memoria.\n",
    "\n",
    "![assets/ModelosAsociativos-04.png](assets/ModelosAsociativos-04.png)\n",
    "\n",
    "* Heteroasociación: Vectores arbitrarios de estímulos son asociados con vectores arbitrarios de respuesta.\n",
    "\n",
    "![assets/ModelosAsociativos-02.png](assets/ModelosAsociativos-02.png)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Por otra parte, se definen dos **tipos de memorias**:\n",
    "\n",
    "* Memoria asociativa lineal: la neurona actúa como un combinador lineal: \n",
    "$$\\mathbf{b}=\\mathbf{Ma}$$\n",
    "Donde $\\mathbf{M}$ es la matriz de memoria, $\\mathbf{a}$ el estímulo, y $\\mathbf{b}$ la respuesta\n",
    "\n",
    "\n",
    "* Memoria asociativa no lineal: \n",
    "$$\\mathbf{b}=\\Phi(\\mathbf{M},\\mathbf{a})$$\n",
    "en la que $\\Phi(.)$ es una función no lineal.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "toc-hr-collapsed": true
   },
   "source": [
    "### Modelo matemático"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Representación como una red neuronal artificial"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Una memoria asociativa lineal puede representarse como la siguiente red neuronal:\n",
    "\n",
    "![assets/ModelosAsociativos-05.png](assets/ModelosAsociativos-05.png)\n",
    "\n",
    "donde:\n",
    "\n",
    "* El $k$-ésimo estímulo o patrón clave es $\\mathbf{a}_k = [a_{k1}, ..., a_{km}]^T$.\n",
    "\n",
    "\n",
    "* El $k$-ésimo vector respuesta o patrón memorizado es $\\mathbf{b}_k = [b_{k1}, ..., b_{kn}]$.\n",
    "\n",
    "\n",
    "* La red asocia $\\mathbf{a}_k$ con $\\mathbf{b}_k$, esto es $\\mathbf{a}_k \\, \\to \\, \\mathbf{b}_k$ como:\n",
    "\n",
    "$$\\mathbf{b}_k = \\mathbf{M} \\mathbf{a}_k$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para $Q$ patrones a asociar, la matriz $\\mathbf{M}$ se calcula como:\n",
    "\n",
    "$$\\mathbf{M} = \\sum_{k=1}^Q \\mathbf{b}_k \\mathbf{a}_k^T \n",
    "= [\\mathbf{b}_1 ... \\mathbf{b}_Q] \n",
    " \\begin{bmatrix} \\mathbf{a}_1^T  \\\\ \\vdots \\\\ \\mathbf{a}_Q^T\\end{bmatrix} \n",
    "= \\mathbf{B} \\mathbf{A}^T\n",
    "$$\n",
    "\n",
    "donde $\\mathbf{A}$ es la matriz clave y $\\mathbf{B}$ es la matriz memorizada."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Propagación de la señal"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Cuando se presenta un estímulo $\\mathbf{a}_j$ la respuesta será:\n",
    "\n",
    "$$\\mathbf{b} = \n",
    "\\mathbf{M} \\mathbf{a_j} = \n",
    "\\sum_{k=1}^Q \\mathbf{b}_k \\mathbf{a}_k^T \\mathbf{a}_j =\n",
    "\\sum_{k=1}^Q (\\mathbf{a}_k^T \\mathbf{a}_j) \\mathbf{b}_k  =\n",
    "(\\mathbf{a}_j^T \\mathbf{a}_j) \\mathbf{b}_j + \n",
    "\\sum_{\\substack{k=1\\\\k \\neq j}}^Q (\\mathbf{a}_k^T \\mathbf{a}_j) \\mathbf{b}_k\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Ya que la red neuronal reproduce perfectamente la salida deseada $\\mathbf{b}_j$, entonces:\n",
    "\n",
    "* Cada patrón de entrada debe estar normalizado $\\mathbf{a}_j^T \\mathbf{a}_j = 1$.\n",
    "\n",
    "\n",
    "* Los patrones de entrada deben ser ortogonales:\n",
    "$$\n",
    "\\mathbf{a}_k^T \\mathbf{a}_j = \n",
    "\\begin{cases}\n",
    "1, & k = j \\\\\n",
    "0, & k \\ne j\n",
    "\\end{cases}\n",
    "$$\n",
    "\n",
    "Y $Q$ debe ser menor que la dimensión de las claves."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Construya la matriz $\\mathbf{M}$ para los siguientes patrones de entrenamiento (realice los cálculos usando NumPy):\n",
    "\n",
    "* $\\mathbf{a}_1 = [+0.5, -0.5, +0.5, -0.5]^T$, $\\mathbf{b}_1 = [+1, -1]^T$.\n",
    "\n",
    "\n",
    "* $\\mathbf{a}_2 = [+0.5, +0.5, -0.5, -0.5]^T$, $\\mathbf{b}_2 = [+1, +1]^T$.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Cómputo de los pesos mediante el método de la pseudoinversa"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En este caso, los vectores de es:\n",
    "\n",
    "$$\\mathbf{b} = \n",
    "\\mathbf{M} \\mathbf{a_j} = \n",
    "(\\mathbf{a}_j^T \\mathbf{a}_j) \\mathbf{b}_j + \n",
    "\\sum_{\\substack{k=1\\\\k \\neq j}}^Q (\\mathbf{a}_k^T \\mathbf{a}_j) \\mathbf{b}_k = \n",
    "\\mathbf{b}_j + \n",
    "\\sum_{\\substack{k=1\\\\k \\neq j}}^Q (\\mathbf{a}_k^T \\mathbf{a}_j) \\mathbf{b}_k =\n",
    "\\mathbf{b}_j+ \\mathbf{v}_j\n",
    "$$\n",
    "\n",
    "donde $\\mathbf{b}_j$ es la respuesta deseada y $\\mathbf{v}_j$ es un vector de ruido, con:\n",
    "\n",
    "$$\\mathbf{v}_j \n",
    "= \\sum_{\\substack{k=1\\\\k \\neq j}}^Q (\\mathbf{a}_k^T \\mathbf{a}_j) \\mathbf{b}_k \n",
    "= \\sum_{\\substack{k=1\\\\k \\neq j}}^Q \\cos (\\mathbf{a}_k, \\mathbf{a_j}) \\mathbf{b}_k \n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Se puede minimizar el error cuando los patrones no son ortogonales aplicando la regla de la pseudoinversa.\n",
    "\n",
    "* Se tienen $Q$ patrones de entrenamiento, con $Q>m$.\n",
    "\n",
    "\n",
    "* Es posible definir una medida del error, tal como la suma de errores al cuadrado:\n",
    "$$\n",
    "J(\\mathbf{M}) \n",
    "= \\sum_{k=1}^Q \\| \\mathbf{b}_k - \\mathbf{Ma}_k) \\|^2\n",
    "= \\| \\mathbf{B} - \\mathbf{MA} \\|^2\n",
    "= \\| \\mathbf{E} \\|^2\n",
    "$$\n",
    "\n",
    "\n",
    "* Derivando e igualando a cero:\n",
    "\n",
    "$$ \\mathbf{B} - \\mathbf{MA} = 0 $$\n",
    "\n",
    "$$ \\mathbf{MA} = \\mathbf{B} $$\n",
    "\n",
    "$$ \\mathbf{M} = \\mathbf{B} \\mathbf{A} ^{-1}$$\n",
    "\n",
    "\n",
    "* Ya que $\\mathbf{A}$ es una matriz rectangular, su inversa exacta no existe. Se recurre a la definición de psuedoinversa. \n",
    "\n",
    "$$ \\mathbf{M} = \\mathbf{B} \\mathbf{A} ^{+}$$\n",
    "\n",
    "$$ \\mathbf{A}^{+} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T $$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Solución"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para el problema propuesto, se tienen tres  patrones de entrenamento, los cuales serán aprendidos por una red neuronal asociativa NO lineal. Este tipo de red neuronal se construye usando una memoria asociativa lineal en la que se cambia la función de activación. La arquitectura del modelo es la siguiente:\n",
    "\n",
    "![assets/ModelosAsociativos-06.png](assets/ModelosAsociativos-06.png)\n",
    "\n",
    "Las figuras son representadas mediante patrones binarios, $\\{-1, +1\\}$, donde $-1$ representa el blanco y $+1$ representa el negro."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "%load_ext rpy2.ipython\n",
    "import math"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def plot_digits(x, y=None):\n",
    "    \"\"\"\n",
    "    Genera el gráfico de patrones por parejas.\n",
    "    \n",
    "    x: lista con los patrones iniciales\n",
    "    y: lista con los patrones limpios\n",
    "    \"\"\"\n",
    "    N = len(x)\n",
    "    if y is None:\n",
    "        fig, axes = plt.subplots(1, N, figsize=(2.9, 1.2))\n",
    "        for i, data in enumerate(x):\n",
    "            axes[i].pcolor(data, edgecolors='grey', linewidths=1, cmap=plt.get_cmap('Greys'))\n",
    "            axes[i].set(xticks=[], yticks=[])\n",
    "    else:\n",
    "        if N == 1:\n",
    "            fig, axes = plt.subplots(N, 2, figsize=(2.0, 1.2))\n",
    "            axes[0].pcolor(x[0], edgecolors='grey', linewidths=1, cmap=plt.get_cmap('Greys'))\n",
    "            axes[1].pcolor(y[0], edgecolors='grey', linewidths=1, cmap=plt.get_cmap('Greys'))\n",
    "            axes[0].set(xticks=[], yticks=[])\n",
    "            axes[1].set(xticks=[], yticks=[])\n",
    "        else:\n",
    "            fig, axes = plt.subplots(N, 2, figsize=(2, 3))\n",
    "            for i, (data_x, data_y) in enumerate(zip(x,y)):\n",
    "                axes[i][0].pcolor(data_x, edgecolors='grey', linewidths=1, cmap=plt.get_cmap('Greys'))\n",
    "                axes[i][1].pcolor(data_y, edgecolors='grey', linewidths=1, cmap=plt.get_cmap('Greys'))\n",
    "                axes[i][0].set(xticks=[], yticks=[])\n",
    "                axes[i][1].set(xticks=[], yticks=[])\n",
    "    fig.tight_layout()\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 208.8x86.4 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "##\n",
    "## Se representan los tres patrones como matrices\n",
    "## Note que las matrices estan invertidas para\n",
    "## efectos de graficación\n",
    "## -1: blanco,  +1: negro\n",
    "##\n",
    "\n",
    "d0 = np.array([[-1, +1, +1, +1, -1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [-1, +1, +1, +1, -1]])\n",
    "\n",
    "d1 = np.array([[-1, -1, +1, -1, -1],\n",
    "               [-1, -1, +1, -1, -1],\n",
    "               [-1, -1, +1, -1, -1],\n",
    "               [-1, -1, +1, -1, -1],\n",
    "               [-1, -1, +1, -1, -1],\n",
    "               [-1, +1, +1, -1, -1]])\n",
    "\n",
    "d2 = np.array([[-1, +1, +1, +1, +1],\n",
    "               [-1, +1, -1, -1, -1],\n",
    "               [-1, +1, +1, -1, -1],\n",
    "               [-1, -1, -1, +1, -1],\n",
    "               [-1, -1, -1, +1, -1],\n",
    "               [+1, +1, +1, +1, -1]])\n",
    "\n",
    "plot_digits(x=[d0, d1, d2])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 144x216 with 6 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "class ALM:\n",
    "    def __init__(self):\n",
    "        self.M = None\n",
    "        \n",
    "    def fit(self, x):\n",
    "        ##\n",
    "        ## Recibe una lista de matrices con los patrones\n",
    "        ##\n",
    "        x = [e.flatten() for e in x]            ## matrix a vector\n",
    "        x = [e / math.sqrt(len(e)) for e in x]  ## normaliza los vectores\n",
    "        x = [e.reshape(len(e), 1) for e in x]   ## vector-fila a vector-columna\n",
    "        A = np.hstack(x)                        ## matriz A = [x0 x1 x2]\n",
    "        self.M = A @ np.linalg.pinv(A)          ## B * inv(A' * A)\n",
    "        \n",
    "    def predict(self, x):\n",
    "        ##\n",
    "        ## x es una lista de matrices\n",
    "        ##\n",
    "        m, n = x[0].shape\n",
    "        x = [e.flatten() for e in x]            ## matrix a vector\n",
    "        x = [e / math.sqrt(len(e)) for e in x]  ## normaliza los vectores\n",
    "        x = (e.reshape(len(e), 1) for e in x)   ## vector-fila a vector-columna\n",
    "        x = [self.M @ e for e in x]\n",
    "        x = [e.reshape(m,n) for e in x]\n",
    "        return x\n",
    "\n",
    "alm = ALM()\n",
    "alm.fit([d0, d1, d2])\n",
    "n = alm.predict([d0, d1, d2])\n",
    "plot_digits(x=[d0, d1, d2], y=n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAIgAAABPCAYAAAAwV41eAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjAsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+17YcXAAAH/klEQVR4nO2dW0hU7xrGn7VcrhkPE5lJ5XTAsIgugiIiKygrk6K6iYoOaKTQgYJuiiAxQsFuuumiG6/KiwpvOuJVpEVCVh5CBCvTqDyk2ajpLGdmre9/IcLmj/O+3/Rvs9t7v7/beXz45pvHcfnwrm8ZSikIQjzM//QChD8bCYhAIgERSCQgAokERCCRgAgkViLiWbNmqQULFpCayclJhMNhTExMsH7p6emYmJiA53mkLiUlBUopOI6js0akp6ezukgkgp6eniGlVBYr/htpaWlq4cKFrG50dBSO4yAWi5E6n88Hy7IwPj7OegYCAbiuC66eME0Ttm3D7/eznuPj4+jt7Z1xLxIKSE5ODtra2khNXV0dbt++jZqaGtbv7NmzuHHjBn7+/Enqdu7ciUgkgvv377OeFy5cwMWLF5GcnEzq6uvrkZ+f/4k1nIG5c+eis7OT1V2+fBk1NTXo7u4mdatXr8aKFStQXV3Nep47dw4fP35kf1mys7Oxfv167N69m/Wsrq7G+fPnZ9wL+RMjkEhABBIJiEAiARFIJCACiQREIJGACCQJ9SCRSATv378nNaFQCKmpqcjNzdXyzMnJYXuQ9PR0RKNRbc8PHz7Asui3Njw8rOU1E0opdh8AwPM8BINBJCUlkbrMzEz4fD7t95eWlsb2PLZtY3x8nO1gAJBFnpHIwFAwGFQnT54kNaZpYmJiArZts36O48C2bZgm/UUWjUbheR58Ph/ryXlNk5SUhEuXLr1RSq3V+oF/IRgMqtOnT7O6aDQK13XZgMRiMbiuy4Z6Gtu2Wc9oNArLstjGFQAMw0BZWdmMe5HQN8jg4CDKy8tJTWFhIYqKinD48GHWr6qqCqdOncLs2bNJXW1tLfx+P/bs2cN6lpeX4+rVq4hGo6Ruy5YtrFc8PM/DzZs3WV1xcTH27duHxYsXk7qXL1+io6MDq1atYj1fvXqFY8eOYd68eaTu0aNHePjwIZ4+fcp6Up+VXIMIJBIQgUQCIpBIQAQSCYhAIgERSCQgAklCPYhhGOwIm2VZcF0X4XBYy3N6RJHCdV3EYjFtT7/fzxZJuqVUPHSKQGCqfeamv2KxGJRSbHczjc6exWIxGIahvc54JNSkZmdnq5KSEtowgUWZpsnOowJT1bZhGFqejuNoaysrK3+pSc3OzlalpaWsTncflFJajScwFWzdPdMNHABUVFT88yZ1aGgIlZWVpCbRJvXMmTP/dU2qUgp37txhdcXFxdi7d+9vb1JLSkqkSRX+DCQgAokERCCRgAgkEhCBRAIikEhABBIJiECSUJM6f/58dfToUVJj2zZSU1ORmprK+oXDYfh8PnaOdLpWTklJYT1DoRDC4TDbTNq2jaqqql9uUouKilhdIBCAZVls7R+JRBCLxdhBZGCqpEtOTmY9HceB4ziIRCKsp9/vx5UrV/55kzo2NoZ79+6RmrVr1yI/Px/btm1j/e7evYuCggKkpaWRuoaGBti2jby8PNbz1q1bePDgAVzXJXU6rWU8lFJobGxkdYWFhdiwYQO4IzPevn2Lnp4erFmzhvVsbGzEunXr2Pa5paUFzc3NaG1tZT23bt0a97WEAhKNRtHV1UVqcnNzEQgEtEb4TdPEkiVLtN6s3+/Xvi2gu7ubrdoXLVqk5RWP/v5+VmMYBoLBIJYuXUrqent70d/fj+zsbNYzKSkJwWAQWVn0sSZdXV1wHEdrnRRyDSKQSEAEEgmIQCIBEUgkIAKJBEQgkYAIJImek4odO3aQmqysLPT29qK2tpb1U0rh8ePH7Ozm58+fYZqmlicA7N+/n21SMzMzUV9fr+X3dwzDwObNm7W0DQ0NePPmDakZHBzEyMgIXrx4wfq5rovnz5+zJx0MDAxgzpw52uuMR8IBOXToEKn59OkTJicntQ5wdV0XPp+PfbOGYcA0TS3PpKQkHDhwgK3v+/r6WC8KnQn76SMduHVPD2/r1OKe58GyLK09U0pp3wkQj4QCEggE2MHhuro6hEIhrQHj9vZ2bN++/bcOLbe2tmLXrl1aB+n+KkopNDU1sbqVK1di48aNbJP67NkzNDc3Y9myZaxnKBRCXl4e26Q+efIEHR0dWuukGmq5BhFIJCACiQREIJGACCQSEIFEAiKQSEAEkoR6kHA4zP5fPTAwgImJCa3/vwGgra2NnTUdHh6GZVnanq9fv2ZnNr9+/arlFY/ly5ezGsMw0NnZiaGhIVL35csXTE5Oore3l/X0PA/v3r1jtd+/f0daWprWOqnWOaGAOI6DlpYWUjM6OgrXdVkdMNU0tre3s2d1hEIhGIah5WkYBlpbW9kmVeeRafEwTVNr5nZkZARNTU3scQ2maUIpxVbyAJCRkYGmpiatR5JlZGSgoKCA9fzx40fc1xIKSEZGBk6cOEFqpptUrpIHpo5/OHLkyG9tUisqKlBaWvpvbVIty8Lx48dZ3fXr1/Hhwwf2qPGsrCx4nqf1SLKysjLtR5Jt2rQJBw8eZD2vXbsW9zW5BhFIJCACiQREIJGACCQSEIFEAiKQSEAEkoR6kFgsxjZ44+PjcBxHqxUEgG/fvrGlVTgchud52p59fX1s+TY2NqblNRNKKQwMDGjpbNtmm+Lk5GR4nsfe5D2Nz+djz4K1LEv7c6BudE/o+AfDMAYB/NLz7v9Qliil6Nm9Gfgf3Acgzl4kFBDh/w+5BhFIJCACiQREIJGACCQSEIFEAiKQSEAEEgmIQCIBEUj+AmR6VbvjgQVeAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 144x86.4 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "##\n",
    "## Se ejecuta el modelo sobre patrones incompletos\n",
    "## o contaminados con ruido\n",
    "##\n",
    "n0 = np.array([[-1, -1, -1, -1, -1],\n",
    "               [-1, -1, -1, -1, -1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [-1, +1, +1, +1, -1]])\n",
    "\n",
    "plot_digits(x=[n0], y=alm.predict([n0]))\n",
    "\n",
    "## Los grises en la figura de abajo se producen porque\n",
    "## la red genera salidas diferentes a {-1,+1}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 144x216 with 6 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "##\n",
    "## Ya que se requiere que la salida sea {-1, +1}\n",
    "## se modifica el codigo anterior agregando la\n",
    "## función de activación de paso duro\n",
    "##\n",
    "class ANLM:\n",
    "    def __init__(self):\n",
    "        self.M = None\n",
    "        \n",
    "    def fit(self, x):\n",
    "        x = [e.flatten() for e in x]            ## matrix a vector\n",
    "        x = [e / math.sqrt(len(e)) for e in x]  ## normaliza los vectores\n",
    "        x = [e.reshape(len(e), 1) for e in x]   ## vector-fila a vector-columna\n",
    "        A = np.hstack(x)                        ## matriz A = [x0 x1 x2]\n",
    "        self.M = A @ np.linalg.pinv(A)          ## B * inv(At * A)\n",
    "        \n",
    "    def predict(self, x):\n",
    "        m, n = x[0].shape\n",
    "        x = [e.flatten() for e in x]            ## matrix a vector\n",
    "        x = [e / math.sqrt(len(e)) for e in x]  ## normaliza los vectores\n",
    "        x = (e.reshape(len(e), 1) for e in x)   ## vector-fila a vector-columna\n",
    "        x = [self.M @ e for e in x]\n",
    "        ##\n",
    "        ## ----- función de activación -------\n",
    "        ##\n",
    "        x = [np.sign(e) for e in x]\n",
    "        ##\n",
    "        ## ------------------------------------\n",
    "        ##\n",
    "        x = [e.reshape(m,n) for e in x]\n",
    "        return x\n",
    "\n",
    "anlm = ANLM()\n",
    "anlm.fit([d0, d1, d2])\n",
    "n = anlm.predict([d0, d1, d2])\n",
    "plot_digits(x=[d0, d1, d2], y=n)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 144x86.4 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "##\n",
    "## Se ejecuta el modelo sobre patrones incompletos\n",
    "## o contaminados con ruido\n",
    "##\n",
    "n0 = np.array([[-1, -1, -1, -1, -1],\n",
    "               [-1, -1, -1, -1, -1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [+1, -1, -1, -1, +1],\n",
    "               [-1, +1, +1, +1, -1]])\n",
    "\n",
    "plot_digits(x=[n0], y=anlm.predict([n0]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Verifique si las siguientes reconstrucciones son correctas.\n",
    "\n",
    "![assets/ModelosAsociativos-07.png](assets/ModelosAsociativos-07.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Implemente el algoritmo anterior usando las operaciones elementales de TensorFlow y con compare los resultados obtenidos usando NumPy."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Apéndice --- Lenguaje R"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Representación numérica de los patrones de ejemplo"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%R\n",
    "##\n",
    "## Se representan los tres patrones como matrices\n",
    "## Note que las matrices estan invertidas para\n",
    "## efectos de graficación\n",
    "## -1: blanco,  +1: negro\n",
    "##\n",
    "\n",
    "a0 <-\n",
    "t(matrix(cbind(c(-1, +1, +1, +1, -1),  #    ###\n",
    "               c(+1, -1, -1, -1, +1),  #   #   #\n",
    "               c(+1, -1, -1, -1, +1),  #   #   #\n",
    "               c(+1, -1, -1, -1, +1),  #   #   #\n",
    "               c(+1, -1, -1, -1, +1),  #   #   #\n",
    "               c(-1, +1, +1, +1, -1)), #    ###\n",
    "         5, 6))\n",
    "\n",
    "a1 <-\n",
    "t(matrix(cbind(c(-1, -1, +1, -1, -1),  #     #\n",
    "               c(-1, -1, +1, -1, -1),  #     #\n",
    "               c(-1, -1, +1, -1, -1),  #     #\n",
    "               c(-1, -1, +1, -1, -1),  #     #\n",
    "               c(-1, -1, +1, -1, -1),  #     #\n",
    "               c(-1, +1, +1, -1, -1)), #    ##\n",
    "         5, 6))         \n",
    "\n",
    "a2 <-\n",
    "t(matrix(cbind(c(-1, +1, +1, +1, +1),  #     ####\n",
    "               c(-1, +1, -1, -1, -1),  #    #\n",
    "               c(-1, +1, +1, -1, -1),  #    ##\n",
    "               c(-1, -1, -1, +1, -1),  #      #\n",
    "               c(-1, -1, -1, +1, -1),  #      #\n",
    "               c(+1, +1, +1, +1, -1)), #   #### \n",
    "         5, 6))                  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Función de graficación de los patrones binarios"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%R\n",
    "##\n",
    "## La siguiente función permite graficar una matriz\n",
    "## de +1s y -1s como una malla de cuadros blancos y \n",
    "## negros\n",
    "##\n",
    "\n",
    "plot_digits <- function(x, y = NULL){\n",
    "\n",
    "    ##\n",
    "    ## Obtiene la cantidad de ejemplos a graficar\n",
    "    ##\n",
    "    N <- length(x)\n",
    "\n",
    "    if(is.null(y)){\n",
    "        ##\n",
    "        ## Solo se están pasando los ejemplos originales\n",
    "        ## en el parámetro x\n",
    "        ##\n",
    "        \n",
    "        ## Se define el tamaño del área del gráfico\n",
    "        options(repr.plot.width=0.9, repr.plot.height=1.2*N)\n",
    "        \n",
    "        ## Se fija el tamaño de las margenes de cada figura\n",
    "        par(mar=c(1,1,1,1))\n",
    "        \n",
    "        ## Se define una columna de gráficas\n",
    "        par(mfrow=c(N,1))\n",
    "        for(i in 1:N){\n",
    "            image(t(x[[i]]), col = grey(seq(1, 0, length = 2)), xaxt=\"n\", yaxt= \"n\")\n",
    "            grid()\n",
    "        }\n",
    "    } else {\n",
    "        ##\n",
    "        ## Se pasan los ejemplos originales en x y \n",
    "        ## los patrones reconstruidos en el parámetro y\n",
    "        ##\n",
    "        \n",
    "        ## Se define el tamaño del área del gráfico\n",
    "        options(repr.plot.width=0.9*2, repr.plot.height=1.2*N)\n",
    "        \n",
    "        ## Se fija el tamaño de las margenes de cada figura\n",
    "        par(mar=c(1,1,1,1))\n",
    "        \n",
    "        ## Se definen dos columnas de gráficas\n",
    "        par(mfrow=c(N,2))\n",
    "        for(i in 1:N){\n",
    "            image(t(x[[i]]), col = grey(seq(1, 0, length = 2)), xaxt=\"n\", yaxt= \"n\")\n",
    "            grid()\n",
    "            image(t(y[[i]]), col = grey(seq(1, 0, length = 2)), xaxt=\"n\", yaxt= \"n\")\n",
    "            grid()\n",
    "        }        \n",
    "    }    \n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%%R\n",
    "## Se grafican los tres patrones de ejemplo\n",
    "## para verificar que la codificación manual\n",
    "## sea correcta\n",
    "options(repr.plot.width=2, repr.plot.height=4)\n",
    "plot_digits(list(a0, a1, a2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%R\n",
    "##\n",
    "## Esta funcion crea directamente la matriz M\n",
    "## que representa los pesos de la red neuronal.\n",
    "##\n",
    "fit_alm <- function(x) {\n",
    "    ##\n",
    "    ## x es una lista de matrices que representan\n",
    "    ## los patrones a ser aprendidos\n",
    "    ##\n",
    "    \n",
    "    ## convierte cada matriz en un vector\n",
    "    x <- lapply(x, as.vector)\n",
    "    \n",
    "    ## hace cada vector unitario\n",
    "    n <- lapply(x, function(v) return(v / sqrt(sum(v^2))))\n",
    "                \n",
    "    ## convierte los elementos a una matriz\n",
    "    m <- matrix(unlist(n, use.names=FALSE), nrow=length(n[[1]]), ncol=length(x))\n",
    "                \n",
    "    ## computa la matriz por minimos cuadrados\n",
    "    mplus <- solve( t(m) %*% m ) %*% t(m)\n",
    "    return(m %*% mplus)\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%R\n",
    "##\n",
    "## Crea una memoria asociativa lineal para \n",
    "## el ejemplo presentado\n",
    "##\n",
    "M <- fit_alm(list(a0, a1, a2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%R\n",
    "##\n",
    "## Dada la matriz M, esta función permite\n",
    "## pronosticar el patrón de salida a partir\n",
    "## de un patrón de entrada x\n",
    "##\n",
    "predict_alm <- function(M, x) {\n",
    "\n",
    "    ## convierte cada matriz en un vector\n",
    "    y <- lapply(x, as.vector)\n",
    "    \n",
    "    ## hace cada vector unitario\n",
    "    n <- lapply(y, function(v) return(v / sqrt(sum(v^2))))\n",
    "                \n",
    "    ## computa la multiplicación de M * x para cada vector\n",
    "    ## se aplica la función sign para transformar la salida \n",
    "    ## a {-1, +1}\n",
    "    r <- lapply(n, function(v) return(sign(M %*% v)))\n",
    "                \n",
    "    ## convierte cada vector en una matriz con las mismas\n",
    "    ## dimensiones de la original\n",
    "    r <- lapply(r, function(v) return(matrix(v, nrow(x[[1]]), ncol(x[[1]]))))\n",
    "\n",
    "    return(r)\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%%R\n",
    "##\n",
    "## Se verifica que la red haya aprendido los\n",
    "## patrones suministrados. La columna izquierda\n",
    "## contiene el patrón original. La columna\n",
    "## derecha presenta el patrón reconstruido\n",
    "##\n",
    "plot_digits(x=list(a0, a1, a2), y=predict_alm(M, x=list(a0, a1, a2)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reconstrucción de patrones incompletos o contaminados con ruido"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%%R\n",
    "##\n",
    "## Se ejecuta el modelo sobre patrones incompletos\n",
    "## o contaminados con ruido\n",
    "##\n",
    "p0 <-\n",
    "t(matrix(cbind(c(-1, +1, +1, +1, -1),\n",
    "               c(+1, -1, -1, -1, +1),\n",
    "               c(+1, -1, -1, -1, +1),\n",
    "               c(+1, -1, -1, -1, +1),\n",
    "               c(-1, -1, -1, -1, -1),\n",
    "               c(-1, -1, -1, -1, -1)),\n",
    "         5, 6))\n",
    "\n",
    "##\n",
    "## La figura de la izquierda es el patrón incompleto,\n",
    "## la figura de la derecha es el patrón reconstruido\n",
    "##\n",
    "plot_digits(x=list(p0), y=predict_alm(M, list(p0)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%%R\n",
    "p0 <-\n",
    "t(matrix(cbind(c(-1, +1, +1, +1, -1),\n",
    "               c(+1, -1, -1, -1, +1),\n",
    "               c(+1, -1, -1, -1, +1),\n",
    "               c(-1, -1, -1, -1, -1),\n",
    "               c(-1, -1, -1, -1, -1),\n",
    "               c(-1, -1, -1, -1, -1)),\n",
    "         5, 6))\n",
    "\n",
    "plot_digits(x=list(p0), y=predict_alm(M, list(p0)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "%%R\n",
    "p1 <-\n",
    "t(matrix(cbind(c(-1, -1, -1, -1, -1),\n",
    "               c(-1, -1, -1, -1, -1),\n",
    "               c(-1, -1, -1, -1, -1),\n",
    "               c(-1, -1, +1, -1, -1),\n",
    "               c(-1, -1, +1, -1, -1),\n",
    "               c(-1, +1, +1, -1, -1)),\n",
    "         5, 6))\n",
    "\n",
    "plot_digits(x=list(p1), y=predict_alm(M, list(p1)))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
