{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "toc-hr-collapsed": false
   },
   "source": [
    "Introducción a TensorFlow\n",
    "===\n",
    "\n",
    "\n",
    "* *60 min* | Última modificación: Julio 12, 2019."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Esta lección presenta una introducción al cómputo numérico usando la API de bajo nivel de TensorFlow, a partir de la cual se construiran modelos de aprendizaje automático en lecciones posteriores. El lector puede referirse a los sitios de oficiales de Keras (https://keras.io) y TensorFlow (https://www.tensorflow.org) para mayor información y para obtener una visión más profunda de las herramientas y metodologías disponibles."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Representación de cómputos mediante su árbol sintáctico."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En el siguiente ejemplo se evaluará la expresión 5 * 3 - (3 + 2). Esta expresión puede ser representada a través del siguiente árbol sintáctico donde los nodos interiores representan las operaciones aritméticas y los nodos finales representan las constantes numéricas:\n",
    "\n",
    "     [-]\n",
    "      +--- [*]\n",
    "      |     +---- [5]\n",
    "      |     +---- [3]\n",
    "      |\n",
    "      +--- [+]\n",
    "            +---- [3]\n",
    "            +---- [2]\n",
    "\n",
    "Note que en esta expresión el nodo con la constante 3 es común a ambas ramas y podría representarse de forma optimizada como:\n",
    "\n",
    "     [-]\n",
    "      +--- [*]\n",
    "      |     +---- [5]\n",
    "      |     +-----------+\n",
    "      |                 |\n",
    "      +--- [+]         [3] \n",
    "            |           |\n",
    "            +-----------+ \n",
    "            +---- [2]   \n",
    "\n",
    "Si se tiene en cuenta que la constante 3 podría ser reemplazada por un cómputo complejo, se hace evidente que dicho cálculo sería realizado una sola vez con la consiguiente economía en el cómputo. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Gráficas computacionales en TensorFlow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El árbol sintáctico anterior es equivalente a una gráfica que representa los cómputos a realizar (gráfica computacional). Para realizar la representación usando TensorFlow, se debe construir explícitamente el grafo que representa el árbol anterior, para lo cual se enumeran los nodos de la siguiente forma:\n",
    "\n",
    "     [-] (node6)\n",
    "      +--- [*] (node4)\n",
    "      |     +---- [5] (node1)\n",
    "      |     +---------------------+\n",
    "      |                           |\n",
    "      +--- [+] (node5)           [3] (node3)\n",
    "            |                     |\n",
    "            +---------------------+ \n",
    "            +---- [2] (node2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La gráfica computacional está conformado por:\n",
    "\n",
    "* **Tensores**: Representa un vector de cualquier número de dimensiones. El rango (**rank**) es el número de dimensiones y la forma (**shape**) es una tupla de enteros indicando el tamaño en cada dimensión. Note que un escalar es un tensor de forma []. Corresponde a los nodos finales de la gráfica computacional.\n",
    "\n",
    "* **Operaciones**: Representan los cálculos. Son los nodos internos de la gráfica computacional."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El código en Python que representa la gráfica computacional es el siguiente:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "##\n",
    "## Se importan las librerías\n",
    "##\n",
    "import tensorflow as tf\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "node1 = tf.constant(5.0)           # Tensor []\n",
    "node2 = tf.constant(2.0)           # Tensor []\n",
    "node3 = tf.constant(3.0)           # Tensor []\n",
    "node4 = tf.multiply(node1, node2)  # Operación\n",
    "node5 = tf.add(node3, node2)       # Operación\n",
    "node6 = tf.subtract(node4, node5)  # Operación "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El código anterior representa el flujo de datos del cómputo, pero no realiza propiamente el cálculo. Por ejemplo, la variable `node1` contiene el objeto en memoria (Tensor):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Tensor(\"Const:0\", shape=(), dtype=float32)\n"
     ]
    }
   ],
   "source": [
    "print(node1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "TensorFlow maneja una gráfica computacional por defecto a la que se van agregando los nodos a medida que se van generando. Esta gráfica puede ser obtenida para su uso con la función `tf.get_default_graph()`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Sin embargo, es posible crear y manipular gráficas computacionales con `tf.Graph()`. En el siguiente ejemplo se crean dos gráficas, una con la expresión  `1+2`  y la otra con `3*4`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "g1 = tf.Graph()\n",
    "g2 = tf.Graph()\n",
    "\n",
    "with g1.as_default():\n",
    "    a = tf.constant(1)\n",
    "    b = tf.constant(2)\n",
    "    c = tf.add(a, b)\n",
    "    \n",
    "with g2.as_default():\n",
    "    e = tf.constant(3)\n",
    "    f = tf.constant(4)\n",
    "    g = tf.multiply(e, f)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## Sesiones en TensorFlow"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para poder ejecutar los cálculos que describe la gráfica computacional es necesario abrir una sesión. Cuando una gráfica de cómputo no es especificada, se usa la gráfica por defecto del sistema (`\n",
    "tf.get_default_graph()`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "outs = 5.0\n"
     ]
    }
   ],
   "source": [
    "##\n",
    "##  Abre la sesión y luego la cierra\n",
    "##\n",
    "with tf.Session() as sess:\n",
    "    outs = sess.run(node6)          ## realiza la evaluación\n",
    "    print(\"outs = {}\".format(outs)) ## imprime el resultado de la evaluación"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "node6 = 5.0\n",
      "node4 = 10.0\n"
     ]
    }
   ],
   "source": [
    "##\n",
    "##  Para computar el resultado en un nodo se puede usar eval()\n",
    "##  Note que es necesario pasar la sesión abierta a eval() \n",
    "##  para realizar la evaluación.\n",
    "##\n",
    "with tf.Session() as sess:\n",
    "    print('node6 = {}'.format(node6.eval()))\n",
    "    print('node4 = {}'.format(node4.eval()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "outs = [5.0, 10.0, 5.0]\n"
     ]
    }
   ],
   "source": [
    "##\n",
    "## run() admite una lista de nodos a evaluar\n",
    "##\n",
    "with tf.Session() as sess:\n",
    "    outs = sess.run([node6, node4, node5])\n",
    "    print(\"outs = {}\".format(outs))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "outs = 5.0\n"
     ]
    }
   ],
   "source": [
    "##\n",
    "## La sesión puede ser almacenada en una variable\n",
    "## y usada en cálculos posteriores\n",
    "##\n",
    "sess = tf.Session()             ## Abre la sesion (en IPython use tf.InteractiveSession())\n",
    "outs = sess.run(node6)          ## Evalua el grafo y almacena el resultado\n",
    "sess.close()                    ## Cierra la sesión\n",
    "print(\"outs = {}\".format(outs)) ## imprime el resultado de la evaluación"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Para pasar una gráfica en particular se usa el parámetro `graph`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n"
     ]
    }
   ],
   "source": [
    "with tf.Session(graph = g1) as sess:\n",
    "    print(sess.run(c))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "12\n"
     ]
    }
   ],
   "source": [
    "with tf.Session(graph = g2) as sess:\n",
    "    print(sess.run(g))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Construya a mano el gráfico de flujo de datos de la expresión\n",
    "\n",
    "$$-0.9 * 2^3 + 2.5 * 2^2 - 3.8 * 2 -4.3$$\n",
    "\n",
    "**Actividad.---** Realice el cómputo anterior usando TensorFlow."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "donde la parte superior corresponde a la grafica colapsada y la parte inferior a la gráfica expandida."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Operaciones con escalares"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En la sección anterior se presentaron algunas operaciones aritméticas con TensorFlow. A continuación se resumen las operaciones aritméticas más comunes (la lista completa de operadores puede ser consultada en https://www.tensorflow.org/api_guides/python/math_ops)\n",
    "\n",
    "    Operacion               equivalente\n",
    "    --------------------------------------\n",
    "    tf.add(a, b)            a + b\n",
    "    tf.multiply(a, b)       a * b\n",
    "    tf.subtract(a, b)       a - b\n",
    "    tf.divide(a, b)         a / b\n",
    "    tf.pow(a, b)            a ** b\n",
    "    tf.mod(a, b)            a % b\n",
    "    \n",
    "    tf.abs(a)               abs(a)\n",
    "    tf.square(a)            a ** 2\n",
    "    tf.sqrt(a)              sqrt(a)\n",
    "    tf.exp(a)               exp(a)\n",
    "    tf.negative(a)          -a\n",
    "    tf.sigmoid(a)           1 / (1 + exp(-a))\n",
    "    tf.sign                 sign(a)\n",
    "    tf.maximum\n",
    "    tf.minimum\n",
    "    \n",
    "    tf.logical_and(a, b)    a & b\n",
    "    tf.logical_or(a, b)     a | b   \n",
    "    tf.greater(a, b)        a > b\n",
    "    tf.greater_equal(a, b)  a >= b\n",
    "    tf.less_equal(a, b)     a <= b\n",
    "    tf.less(a, b)           a < b\n",
    "    tf.logical_not(a)       ~a \n",
    "    tf.equal(a, b)          a == b\n",
    "    tf.not_equal            a != b\n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "**Actividad.--** Compute las siguientes expresiones usando TensorFlow y use TensorBoard para visualizar las gráficas computacionales.\n",
    "\n",
    "* $|3 - 4| - (4 - 3)$\n",
    "\n",
    "\n",
    "* $\\sqrt{3^2 - 4*3*1}$\n",
    "\n",
    "\n",
    "* $\\frac{1}{2}*3^2 - \\frac{5*2 - \\exp{(-2)}}{3^2}$\n",
    "\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Operaciones matriciales"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "TensorFlow también soporta una gran cantidad de operaciones matriciales. A continuación se presentan ejemplos de las más comunes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1. 1. 1.]\n",
      " [1. 1. 1.]\n",
      " [1. 1. 1.]]\n"
     ]
    }
   ],
   "source": [
    "## Convierte una matriz de numpy a un tensor\n",
    "with tf.Session() as sess:\n",
    "    a = np.ones((3,3))\n",
    "    b = tf.convert_to_tensor(a).eval()\n",
    "print(b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0. 0.]\n",
      " [0. 0.]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de 2x2 con ceros\n",
    "with tf.Session() as sess:\n",
    "    print(tf.zeros((2,2)).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1. 1.]\n",
      " [1. 1.]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de 2x2 con unos\n",
    "with tf.Session() as sess:\n",
    "    print(tf.ones((2,2)).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[-0.20506313  0.17841227]\n",
      " [ 1.5516684   0.30868837]\n",
      " [-0.03633828  1.4230912 ]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de 3x2 con aleatorios \n",
    "## normales estándar\n",
    "with tf.Session() as sess:\n",
    "    print(tf.random_normal((3,2),     ## shape\n",
    "                           0,         ## mean\n",
    "                           1).eval()) ## sd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 1.3468192  -0.480845  ]\n",
      " [ 0.26967958  0.28794277]\n",
      " [ 1.4879166   1.8170801 ]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de 3x2 con aleatorios \n",
    "## normales truncado\n",
    "with tf.Session() as sess:\n",
    "    print(tf.truncated_normal((3,2),     ## shape\n",
    "                              0,         ## mean\n",
    "                              1).eval())  ## sd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0.03041756 0.9151478 ]\n",
      " [0.69149184 0.716274  ]\n",
      " [0.05151224 0.90072906]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de aleatorios uniformes de 3x2\n",
    "with tf.Session() as sess:\n",
    "    print(tf.random_uniform((3,2),     ## shape\n",
    "                            0,         ## minval\n",
    "                            1).eval())  ## maxval"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[4 4]\n",
      " [4 4]\n",
      " [4 4]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de 3x2 lleno de 4s.\n",
    "with tf.Session() as sess:\n",
    "    print(tf.fill((3,2),      ## shape\n",
    "                  4).eval())   ## value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.         0.1        0.2        0.3        0.4        0.5\n",
      " 0.6        0.7        0.8        0.90000004 1.        ]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor de reales igualmente\n",
    "## espaciados entre 0.0 y 1.0\n",
    "with tf.Session() as sess:\n",
    "    print(tf.linspace(0.0, 1.0, 11).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2 3]\n",
      " [4 5 6]]\n"
     ]
    }
   ],
   "source": [
    "## crea un tensor constante a partir de \n",
    "## una lista de listas que representa una\n",
    "## matriz\n",
    "with tf.Session() as sess:\n",
    "    print(tf.constant([[1,2,3], \n",
    "                       [4,5,6]]).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4 5 2 1 3 6]\n"
     ]
    }
   ],
   "source": [
    "## genera un tensor mezclando los elementos\n",
    "## de un tensor constante\n",
    "with tf.Session() as sess:\n",
    "    print(tf.random_shuffle(tf.constant([1,2,3,4,5,6])).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "## crea un tensor a partir de una lista\n",
    "## de lista que representa una matriz\n",
    "with tf.Session() as sess:\n",
    "    m = tf.constant([[1,2,3], \n",
    "                     [4,5,6]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[5 7 9]\n"
     ]
    }
   ],
   "source": [
    "## suma de las columnas de un tensor\n",
    "with tf.Session() as sess:\n",
    "    print(tf.reduce_sum(m, reduction_indices = 0).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[ 6 15]\n"
     ]
    }
   ],
   "source": [
    "## suma de las filas de un tensor\n",
    "with tf.Session() as sess:\n",
    "    print(tf.reduce_sum(m, reduction_indices = 1).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "21\n"
     ]
    }
   ],
   "source": [
    "## suma de todos los elementos de un tensor\n",
    "with tf.Session() as sess:\n",
    "    print(tf.reduce_sum(m).eval())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "TensorFlow implementa las siguiente funciones para reducir un tensor (https://www.tensorflow.org/api_guides/python/math_ops#Reduction)\n",
    "\n",
    "    tf.reduce_sum\n",
    "    tf.reduce_prod\n",
    "    tf.reduce_min\n",
    "    tf.reduce_max\n",
    "    tf.reduce_mean\n",
    "    tf.reduce_all\n",
    "    tf.reduce_any\n",
    "    tf.reduce_logsumexp\n",
    "    tf.count_nonzero\n",
    "    tf.accumulate_n\n",
    "    tf.einsum\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(2, 3)\n"
     ]
    }
   ],
   "source": [
    "## obtiene las dimensiones de un tensor\n",
    "with tf.Session() as sess:\n",
    "    m = tf.constant([[1,2,3], \n",
    "                     [4,5,6]])\n",
    "    print(m.get_shape())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 2  4  6]\n",
      " [ 8 10 12]]\n"
     ]
    }
   ],
   "source": [
    "## suma dos tensores\n",
    "with tf.Session() as sess:\n",
    "    a = m + m\n",
    "    print(a.eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2 3 4 5 6]]\n"
     ]
    }
   ],
   "source": [
    "## cambia las dimensiones de un tensor\n",
    "with tf.Session() as sess:\n",
    "    print(tf.reshape(m,(1,6)).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2]\n",
      " [3 4]\n",
      " [5 6]]\n"
     ]
    }
   ],
   "source": [
    "## cambia las dimensiones de un tensor\n",
    "with tf.Session() as sess:\n",
    "    print(tf.reshape(m,(3,2)).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 7  4]\n",
      " [ 6 14]]\n"
     ]
    }
   ],
   "source": [
    "## suma varios tensores elemento a elemento\n",
    "##  \n",
    "##  |1  2|     |5  0|     |1  2|    |7  4|\n",
    "##  |    |  +  |    |  +  |    |  = |    |\n",
    "##  |3  4|     |0  6|     |3  4|    |6 14|\n",
    "##\n",
    "with tf.Session() as sess:\n",
    "    a = tf.constant([[1, 2], \n",
    "                     [3, 4]])\n",
    "    b = tf.constant([[5, 0], \n",
    "                     [0, 6]])\n",
    "    print(tf.accumulate_n([a, b, a]).eval())  # [[7, 4], [6, 14]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 7  4]\n",
      " [ 6 14]]\n"
     ]
    }
   ],
   "source": [
    "## suma varios tensores elemento a elemento\n",
    "with tf.Session() as sess:\n",
    "    print(tf.add_n([a, b, a]).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n"
     ]
    }
   ],
   "source": [
    "## Busca el valor máximo en el tensor y devuelve la posición contando desde cero\n",
    "with tf.Session() as sess:\n",
    "    print(tf.argmax(tf.constant([1,3,2,4,0])).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "4\n"
     ]
    }
   ],
   "source": [
    "## Busca el valor mínimo en el tensor y devuelve la posición contando desde cero\n",
    "with tf.Session() as sess:\n",
    "    print(tf.argmin(tf.constant([1,3,2,4,0])).eval())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/ops/tensor_array_ops.py:162: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.\n",
      "Instructions for updating:\n",
      "Colocations handled automatically by placer.\n",
      "[1. 0.]\n"
     ]
    }
   ],
   "source": [
    "## Aplica una función a cada elemento de un tensor\n",
    "## La función f() se aplica al argumento m.\n",
    "f = lambda m : tf.cond(tf.greater_equal(m, 0.0), \n",
    "                       true_fn  = lambda :  tf.constant(1.), \n",
    "                       false_fn = lambda : tf.constant(0.0))\n",
    "## define el tensor x\n",
    "x = tf.constant([10.0, -1.0])\n",
    "\n",
    "## aplica la función f a cada elemento de x\n",
    "y = tf.map_fn(f, x)\n",
    "\n",
    "with tf.Session() as sess:\n",
    "    print(sess.run(y))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Para las matrices\n",
    "\n",
    "$$\\mathbf{X} =\n",
    "\\left[\n",
    "  \\begin{array}{cc}\n",
    "     1.0 & 2.1 \\\\\n",
    "     1.9 & 3.2 \\\\\n",
    "     3.0 & 3.9 \\\\\n",
    "     4.2 & 5.2 \n",
    "  \\end{array}\n",
    "\\right],\n",
    "\\qquad \\mathbf{y} = \n",
    "\\left[\n",
    "  \\begin{array}{c}\n",
    "     3.1 \\\\\n",
    "     4.0 \\\\\n",
    "     5.1 \\\\\n",
    "     6.1  \n",
    "  \\end{array}\n",
    "\\right]\n",
    "$$\n",
    "\n",
    "compute\n",
    "\n",
    "* $\\mathbf{z} = (\\mathbf{X}' \\mathbf{X})^{-1} \\mathbf{X}' \\mathbf{y}$\n",
    "\n",
    "\n",
    "* $\\mathbf{p} = \\mathbf{X} \\mathbf{z}$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Indique para que sirven las siguientes funciones del modulo `tf` y realice un ejemplo:\n",
    "\n",
    "    tf.clip_by_value\n",
    "    tf.clip_by_norm\n",
    "    tf.clip_by_average_norm\n",
    "    tf.clip_by_global_norm\n",
    "    tf.clip_by_norm\n",
    "    tf.concat\n",
    "    tf.case\n",
    "    tf.cond\n",
    "    tf.cumprod\n",
    "    tf.cumsum\n",
    "    tf.diag\n",
    "    tf.inverse_permutation\n",
    "    tf.log_sigmoid \n",
    "    tf.map_fn\n",
    "    \n",
    "    tf.matrix_inverse\n",
    "    tf.matrix_diag\n",
    "    tf.matrix_set_diag\n",
    "    tf.matrix_solve\n",
    "    tf.matrix_transpose\n",
    "    tf.parallel_stack\n",
    "    tf.stack\n",
    "    tf.random_shuffle\n",
    "    tf.reverse\n",
    "    \n",
    "    tf.maximum\n",
    "    tf.minimum"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Variables y Placeholders"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Las variables en TensorFlow pueden entenderse como las variables locales de una función, las cuales no pueden ser accesadas desde el exterior. Los placeholders son equivalentes a los parámetros, los cuales pueden tomar cualquier valor cuando se llama la función. En el siguiente ejemplo se evalua la expresión a * b - (b + c) para diferentes valores de a, b y c.\n",
    "\n",
    "     [-] (node6)\n",
    "      +--- [*] (node4)\n",
    "      |     +---- [a] (node1)\n",
    "      |     +---------------------+\n",
    "      |                           |\n",
    "      +--- [+] (node5)           [b] (node2)\n",
    "            +---- [c] (node3)     |\n",
    "            +---------------------+ "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10.0\n",
      "3.0\n",
      "8.0\n"
     ]
    }
   ],
   "source": [
    "## define a, b y c como placeholders\n",
    "a = tf.placeholder(tf.float32)\n",
    "b = tf.placeholder(tf.float32)\n",
    "c = tf.placeholder(tf.float32)\n",
    "\n",
    "## define los nodos de cómputo\n",
    "node4 = tf.multiply(a, b)\n",
    "node5 = tf.add(c, b)\n",
    "node6 = tf.subtract(node4, node5)\n",
    "\n",
    "## evalua la operación para diferentes valores de a, b y c.\n",
    "with tf.Session() as sess:\n",
    "    print(sess.run(node6, feed_dict={a: 5, b:3, c:2}))\n",
    "    print(sess.run(node6, feed_dict={a: 4, b:2, c:3}))\n",
    "    print(sess.run(node6, feed_dict={a: 4, b:3, c:1}))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[ 0.4894185  -0.33874786  0.7626736 ]\n",
      " [-1.6902115   0.14211619  0.95860374]\n",
      " [ 0.07947559 -0.45718622  1.4384198 ]]\n"
     ]
    }
   ],
   "source": [
    "##\n",
    "## la misma operación pero matricial\n",
    "##\n",
    "a = tf.placeholder(tf.float32, shape=(3,3))\n",
    "b = tf.placeholder(tf.float32, shape=(3,3))\n",
    "c = tf.placeholder(tf.float32, shape=(3,3))\n",
    "\n",
    "node4 = tf.multiply(a, b)\n",
    "node5 = tf.add(c, b)\n",
    "node6 = tf.subtract(node4, node5)\n",
    "\n",
    "with tf.Session() as sess:    \n",
    "    print(sess.run(node6, feed_dict={a: [[1, 0, 0,],\n",
    "                                         [0, 1, 0,],\n",
    "                                         [0, 0, 1,]],\n",
    "                                     b: np.random.normal(size=(3,3)), \n",
    "                                     c: np.random.normal(size=(3,3))}))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "El siguiente ejemplo presente un acumulador para el calculo de $n = n + 1$.\n",
    "\n",
    "    [=] (node1)  \n",
    "     +---[n]\n",
    "     +---[+] (node0)\n",
    "          +----[n]\n",
    "          +----[1]\n",
    "     "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "2\n",
      "3\n",
      "4\n",
      "5\n"
     ]
    }
   ],
   "source": [
    "## crea la variable y la inicializa a cero\n",
    "n = tf.Variable(0)\n",
    "\n",
    "## arbol sintactico que representa las operaciones\n",
    "node0 = tf.add(n, tf.constant(1))\n",
    "node1 = tf.assign(n, node0)\n",
    "\n",
    "## evalua\n",
    "with tf.Session() as sess:\n",
    "    \n",
    "    ## las variables deben ser inicializadas antes\n",
    "    ## de usarse\n",
    "    sess.run(tf.global_variables_initializer())\n",
    "    \n",
    "    for i in range(5):\n",
    "        \n",
    "        ## el valor de las variables se retiene entre\n",
    "        ## las llamadas a run()\n",
    "        print(sess.run(node1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "2\n",
      "3\n",
      "4\n",
      "5\n"
     ]
    }
   ],
   "source": [
    "## crea la variable y la inicializa a cero\n",
    "n = tf.Variable(0)\n",
    "\n",
    "## arbol sintactico que representa las operaciones\n",
    "## se usa tf.assign_add para simplificar el arbol\n",
    "## tambien existe tf.assign_sub\n",
    "node0 = tf.assign_add(n, tf.constant(1))\n",
    "with tf.Session() as sess:\n",
    "    sess.run(tf.global_variables_initializer())\n",
    "    for i in range(5):\n",
    "        print(sess.run(node0))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Evalue la función\n",
    "\n",
    "$$f(x) = 0.3x^3 - 0.6x^2 - 0.1x + 0.5$$\n",
    "\n",
    "para el vector\n",
    "\n",
    "\n",
    "$$\\mathbf{x} = \n",
    "\\left[\n",
    "  \\begin{array}{c}\n",
    "     1.0 \\\\\n",
    "     4.2 \\\\\n",
    "     3.1 \\\\\n",
    "     6.3  \n",
    "  \\end{array}\n",
    "\\right]\n",
    "$$\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Actividad.---** Genere los 10 primeros términos de la serie de Fibonacci usando TensorFlow.\n",
    "\n",
    "    1, 1, 2, 3, 5, 8, 13, ..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Uso de TensorFlow con otras librerías de Python"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Los resultados de cómputos realizados con TensorFlow pueden ser asignados a variables en Python para ser usados directamente con otras librerías. En el siguiente ejemplo, se generan 20 puntos  aleatorios normales estándar y luego se grafican usando `matplotlib`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "\n",
    "## Genera un tensor de 2x20 con valores aleatorios \n",
    "a = tf.random_normal([2, 20])\n",
    "\n",
    "## Realiza el cómputo\n",
    "with tf.Session() as sess:\n",
    "    result = sess.run(a)\n",
    "    \n",
    "## Asigna las columnas de la matriz a x y y    \n",
    "x, y = result\n",
    "\n",
    "## Construye el gráfico\n",
    "plt.scatter(x, y, color='red');"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
